package com.quarkdown.cli.creator

import com.quarkdown.cli.creator.content.ProjectCreatorInitialContentSupplier
import com.quarkdown.cli.creator.template.ProjectCreatorTemplatePlaceholders
import com.quarkdown.cli.creator.template.ProjectCreatorTemplateProcessorFactory
import com.quarkdown.core.pipeline.output.ArtifactType
import com.quarkdown.core.pipeline.output.OutputResource
import com.quarkdown.core.pipeline.output.TextOutputArtifact
import com.quarkdown.core.template.TemplateProcessor

/**
 * Generator of resources for a new Quarkdown project via [createResources].
 * Based on different properties, the resources and their content may vary.
 * @param templateProcessorFactory factory that generates the template for the main file
 * @param initialContentSupplier supplier of the initial content (code content and assets)
 * @param mainFileName name of the main file, without extension
 * @see com.quarkdown.cli.creator.template.DefaultProjectCreatorTemplateProcessorFactory
 * @see com.quarkdown.cli.creator.content.DefaultProjectCreatorInitialContentSupplier
 * @see com.quarkdown.cli.creator.content.EmptyProjectCreatorInitialContentSupplier
 */
class ProjectCreator(
    private val templateProcessorFactory: ProjectCreatorTemplateProcessorFactory,
    private val initialContentSupplier: ProjectCreatorInitialContentSupplier,
    private val mainFileName: String,
) {
    /**
     * Finalizes the template processor by injecting into it:
     * - The main file name
     * - The initial example content, processed via the same template processor
     * @param template the template processor to finalize
     * @return the finalized template processor
     */
    private fun finalizeTemplateProcessor(template: TemplateProcessor): TemplateProcessor {
        // The main file name is injected before copying,
        // so that the initial content template can reference it.
        template.optionalValue(ProjectCreatorTemplatePlaceholders.MAIN_FILE, mainFileName)

        // Initial content is processed via the same template processor.
        val initialContentCode =
            initialContentSupplier.templateCodeContent
                ?.let { template.copy(text = it).process().trim() }

        // Processed initial content is injected into the main template.
        template.optionalValue(ProjectCreatorTemplatePlaceholders.INITIAL_CONTENT, initialContentCode)

        return template
    }

    /**
     * @return a collection of resources generated by this project creator
     */
    fun createResources(): Set<OutputResource> {
        val resources =
            this.templateProcessorFactory.createFilenameMappings().map { (fileName, processor) ->
                TextOutputArtifact(
                    fileName ?: mainFileName,
                    finalizeTemplateProcessor(processor).process().trim(),
                    ArtifactType.QUARKDOWN,
                )
            }

        return buildSet {
            addAll(resources)
            addAll(initialContentSupplier.createResources())
        }
    }
}
