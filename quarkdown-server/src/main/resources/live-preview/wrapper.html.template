<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quarkdown Live Preview</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: white;
        }

        .frame-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: white;
            transform: translateZ(0);
        }

        .content-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
            z-index: 999999;
            background-color: white;
            transition: opacity 0.3s ease-in-out;
            will-change: opacity, transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
        }

        .hidden {
            opacity: 0;
            z-index: 999998;
            pointer-events: none;
        }

        .visible {
            opacity: 1;
            z-index: 999999;
            pointer-events: auto;
        }

        .debug .frame-container {
            display: flex;
            flex-direction: row;
        }

        .debug .content-frame {
            position: relative;
            width: 50%;
            border: 2px solid red;
        }

        .debug .hidden {
            opacity: .5;
        }
    </style>
</head>
<body>
<!-- Double frame buffer makes preview updates smoother -->
<div class="frame-container">
    <iframe id="frame-0" class="content-frame visible" src="[[SRCFILE]]"></iframe>
    <iframe id="frame-1" class="content-frame hidden" src="[[SRCFILE]]"></iframe>
</div>
<script data-name="websockets">
    /**
     * Starts a WebSocket connection to the specified server and endpoint.
     * @param {string} serverUrl - The server URL (e.g., `localhost:8080`).
     * @param {string} endpoint - The WebSocket endpoint (e.g., `reload`).
     * @param {function} onMessage - The callback function to handle incoming messages.
     * @returns {WebSocket} The WebSocket instance.
     */
    function startWebSocket(serverUrl, endpoint, onMessage) {
        const socket = new WebSocket(`ws://${serverUrl}/${endpoint}`);

        socket.addEventListener('open', () => {
            console.log('Connected to server ' + socket.url);
        });

        socket.addEventListener("message", onMessage);

        socket.addEventListener('close', (event) => {
            console.log(`WebSocket closed: Code=${event.code}, Reason=${event.reason}`);
            // Automatically reconnect after a brief delay.
            setTimeout(() => startWebSocket(serverUrl, endpoint, onMessage), 1000);
        });

        socket.addEventListener("error", (error) => {
            console.error("WebSocket error:", error);
        });

        return socket;
    }

    /**
     * Starts the WebSocket that reload the content when a message is received.
     */
    function startReloadWebSocket(serverUrl) {
        startWebSocket(serverUrl, 'reload', reload);
    }
</script>
<script data-name="messaging">
    // Scalable message listener registry, with event type as the key and the handler function as the value.
    const messageListeners = new Map();

    // Listens for messages from the iframe content.
    window.addEventListener('message', (event) => {
        const data = event.data;
        if (!data || data.source !== 'quarkdown') return;

        const listener = messageListeners.get(data.event);
        listener?.(data);
    });
</script>
<script data-name="double-buffering">
    const NUM_FRAMES = 2;

    let activeFrameId = 0;
    let inactiveFrameId = 1;

    let scrollX = 0;
    let scrollY = 0;
    let isScrollStickyToBottom = false;

    /**
     * @returns {HTMLIFrameElement} The frame element which is currently active (visible).
     */
    function getActiveFrame() {
        return document.getElementById(`frame-${activeFrameId}`);
    }

    /**
     * @returns {HTMLIFrameElement} The frame element which is currently inactive (hidden).
     */
    function getInactiveFrame() {
        return document.getElementById(`frame-${inactiveFrameId}`);
    }

    /**
     * @returns {boolean} Whether the scroll position is at the veryt bottom of the page
     */
    function isScrolledToBottom(activeFrame) {
        const frameWindow = activeFrame.contentWindow;
        if (!frameWindow) return false;

        const scrollableHeight = frameWindow.document.body.scrollHeight;
        const viewportHeight = frameWindow.innerHeight;
        const scrollY = frameWindow.scrollY || 0;

        // If content fits in viewport or scrolled to bottom.
        return scrollableHeight <= viewportHeight || scrollY >= scrollableHeight - viewportHeight - 1;
    }

    /**
     * Synchronizes scroll of the given frame to the stored scroll position.
     * If the user is scrolled to the bottom, keeps them at the bottom after reload.
     * Otherwise, restores the previous scroll position.
     * @param {HTMLIFrameElement} frame - The frame element
     */
    function syncScrollPosition(frame) {
        const y = isScrollStickyToBottom ? frame.contentWindow.document.body.scrollHeight : scrollY;
        frame.contentWindow.scrollTo(scrollX, y);
    }

    /**
     * Sets up scroll event listeners on the active frame to sync scroll position to the buffered frame.
     * @param {HTMLIFrameElement} active - The currently active frame
     */
    function setupScrollSync(active) {
        active.contentWindow.onscroll = () => {
            if (active?.contentWindow?.scrollY) {
                scrollX = active.contentWindow.scrollX;
                scrollY = active.contentWindow.scrollY;
                isScrollStickyToBottom = isScrolledToBottom(active);
            }
        };
    }

    /**
     * Toggles the visibility class of a frame
     * @param {HTMLElement} frame - The frame element
     * @param {boolean} isVisible - Whether the frame should be visible
     */
    function setFrameVisibility(frame, isVisible) {
        const visible = 'visible';
        const hidden = 'hidden';
        if (isVisible) {
            frame.classList.remove(hidden);
            frame.classList.add(visible);
        } else {
            frame.classList.remove(visible);
            frame.classList.add(hidden);
        }
    }

    /**
     * Swaps the visibility of the frames after the hidden one has loaded and synchronizes scroll position between frames.
     */
    function swapFrames() {
        const currentFrame = getActiveFrame();
        const newFrame = getInactiveFrame();

        // Reset handlers.
        currentFrame.contentWindow.onscroll = null;
        newFrame.contentWindow.onscroll = null;
        newFrame.onload = null;

        // Swap frame visibility.
        setFrameVisibility(newFrame, true);
        setFrameVisibility(currentFrame, false);

        // Update active/inactive frame IDs.
        const previousActive = activeFrameId;
        activeFrameId = inactiveFrameId;
        inactiveFrameId = previousActive;
    }
</script>
<script data-name="reload">
    /**
     * Reloads the preview using double buffering to prevent flickering.
     * Ensures the frame is properly prepared before reloading.
     */
    function reload() {
        inactiveFrameId = (activeFrameId + 1) % NUM_FRAMES;
        const active = getActiveFrame();
        const nextFrame = getInactiveFrame();

        // Make sure the frame to reload is properly hidden.
        setFrameVisibility(nextFrame, false);

        // (#199) If the URL has changed (e.g. different slide, subdocument, etc.),
        // sync the inactive frame's src before reloading.
        const activeUrl = active.contentWindow?.location?.href;
        if (activeUrl && nextFrame.src !== activeUrl) {
            nextFrame.src = activeUrl;
            // Setting src triggers a load, so swap on that load event instead of calling reload.
            nextFrame.onload = swapFrames;
            return;
        }

        // Set up the load event before reloading.
        nextFrame.onload = swapFrames;

        // Reload the hidden frame.
        nextFrame?.contentWindow?.location?.reload();
    }

    /**
     * Synchronizes the scroll position of the currently active frame.
     */
    function syncActiveScroll() {
        const frame = getActiveFrame();
        if (frame && frame.contentWindow) {
            syncScrollPosition(frame);
            setupScrollSync(frame);
        }
    }

    // When rendering is completed in the iframe, syncs scroll position.
    messageListeners.set('postRenderingCompleted', syncActiveScroll);
</script>
<script>startReloadWebSocket("localhost:[[SERVERPORT]]")</script>
</body>
</html>
