.docname {Pipeline - Post rendering}
.include {_Setup.qd}

> Main packages: .repolink {`core.rendering`} {tree/main/quarkdown-core/src/main/kotlin/com/quarkdown/core/rendering}, .repolink {`core.template`} {tree/main/quarkdown-core/src/main/kotlin/com/quarkdown/core/template}, .repolink {`core.pipeline.output`} {tree/main/quarkdown-core/src/main/kotlin/com/quarkdown/core/pipeline/output}
>
> Rendering modules: .repolink {`quarkdown-html`} {tree/main/quarkdown-html}

After obtaining the translation of the AST to the target format from the [Renderer](Pipeline---Rendering.qd), you might notice that it is not enough to display to the user. Considering the HTML format, that is just the content that would go inside `<body>`, but everything else is missing: metadata, styling, and possibly a runtime.

Here comes the *post-renderer*, which takes a template ([HTML sample](https://github.com/iamgio/quarkdown/blob/main/quarkdown-html/src/main/resources/render/html-wrapper.html.template)), made for an ad-hoc engine, and injects all the needed data into it, such as:
- The content itself, placed into `<body>`
- The document target (plain/slides/paged). Each target requires different scripts and stylesheets
- User-defined properties, such as title and page format
- The need to load certain libraries, such as MathJax for rendering LaTeX formulas. This is only done if at least one formula is used

On top of that, the post-renderer is also responsible for returning the output resources of the compilation. These resources include:
- The generated HTML
- The group of stylesheets (global stylesheet, layout theme, and color theme)
- The group of required runtime scripts

These resources are then added to those provided by the [media storage](Media-storage.qd) and ultimately returned by the pipeline.
It is then up to the invoker to handle those resources, which in the case of .repolink {CLI} {tree/main/quarkdown-cli} are saved to file.
